import React from "react";
import ReactDOM from "react-dom/client";
import Header from "./components/Header";
import Body from "./components/Body";

//! Lesson - 6 - Let's Explore the world

//*monolith architecture(used in old days):- Monolithic architecture is a type of software design where a single application contains all the necessary code and data for that application which includes code for api separately written for the app, user interface code , authentication code, code to retrieve data from database, code for sending messages to user and code to send mail to user, etc. . It's a traditional and simple approach, but can become complex to manage as the application grows in size and functionality so much bigger.

//* microservices architecture:- Microservice architecture is a design approach where an application is built as a collection of small services, each service running in its own process and communicating with lightweight mechanisms, often an HTTP resource API. Each service is built around a specific business capability and can be deployed independently. This architecture is known for its flexibility and scalability, but it also requires more coordination and monitoring than monolithic architectures.
//* and one more advantage is that each of the services can be written in different in different languages, like ui microservice written in REACT, Backend microservice written in java, database written in python, sms microservice written in go lang. that's the independence we get when we use microservices.so depending on the the service they are building developer can choose we language will be best to do that. And the developers can upload there code to repositories which is separate for that service ,all of developers   don't need to  work on the same repository like they do while using monolith architecture     On the other hand , if we were using monolith architecture then we could use only one language to write all of these features.

//*difference between monolith and microservices :-Monolithic architecture is a single, self-contained application with tightly coupled components. In contrast, Microservices architecture breaks down the application into smaller, loosely coupled services that can be developed, deployed, and scaled independently.
//*This difference provides microservices with greater flexibility and scalability, but also introduces complexity in terms of service coordination and data consistency. The choice between the two often depends on the specific needs and context of the project.

//* Separation of concerns(SoC):- so while using microservices achitecture all of services (like api, database, sms, mail, ui) are divided into small services , for every service we create a separate small project, like for data base there will separate project or for the sms feature we will have a separate project, then we combine all of these microservices together and this services talk to each other depending on the use case and this design principle is know as separation of concerns. and this follows single responsibility principle where each and every service has its own job. This principle aims to improve the system's modularity, reducing the complexity and increasing the maintainability of the system. It's a key concept in both monolithic and microservice architectures, but it's more strictly enforced in microservices where each service handles a single concern or functionality.

//*⁡⁢⁣⁢but how these services are connected with each other?⁡
//* right now our website is running on localhost:1234 port(here 1234 is the port), similarly all of the services runs on their own specific port for example:-
//* on port :1234 - UI service is running
//* on port :1000 - Backend service is running
//* on port :3000 - SMS service is running
//* so on different ports we can deploy different services , and then all of this ports can be mapped  to one domain name.like :- www.anupam.com, then
//* port :1234 is mapped to just / (only slash because it will directly open when the user opens the website) then when the url is www.anupam.com/ then this 1234 port will run.
//* port :1000 is mapped to /api subdirectory then when the url is www.anupam.com/api then this 1000 port will run.
//* port :3000 is mapped to /sms subdirectory then when the url is www.anupam.com/sms then this 3000 port will run.
//* but then how this services interact ?
//* to interact with each other , the services make call to different urls like if the UI is hosted on "/" subdirectory and the Ui want to interact with the backend service then it call the url with /api subdirectory to reach :1000 port.
//* so basically all of the ports are mapped to the main url using different subdirectories like /api or /sms and when the service need to interact with another one then they make call to the port related to the service using this subdirectory names by placing after the main url like www.anupam.com/api or www.anupam.com/sms .

//? ways of fetching data in react (when user first loads the page)
//* see image:- ( "ways of fetching data in react.png")
//* now let's make our web app more dynamic,till now we were copy pasted the api data from swiggy's api but it is not good practice , so now we will try to fetch the data directly from the api , now in react there mainly two ways of fetching data to render it on the ui.
//*1. loads => api call(500ms) => Render , in this when the user loads the page then browser immediately makes an api call and that api call takes 500 ms to retrieve the data , then immediately the bal;cnk Ui will be filled using the data, so the have to wait for 500ms with the blank page and then the data arrives and suddenly all the data will be displayed.
//*2. Loads => Render(just skeleton) => api call(500ms) => Rerender. in this approach when the user open the website immediately some skeleton data will be shown to the user not a a blank page, then immediately the browser makes an api call and then after 500ms when the arrives then it rerenders the Ui with the arrived data.
//* this second process may look complicated but this is actually better , user experience friendly approach, because in the first approach the user had to wait for 500ms to see the ui before that he was seeing the blank page but then suddenly the data arrives and the user sees the Ui and it is very bad for user experience, but in the second approach , as soon as the user opens the website, a Ui skeleton at least will be shown to him then the browser makes the api call and then when the data comes the rerenders the ui and display the data which very good for user Experience. because in this approach , the user doesn't sees the blank page when he open the website first time, so we will try to use use this second approach.
//* so in react we always use the second approach. and to use it we have learn about useEffect() hook.
//? What is a hook? => as we learned in the previous lesson that a hook is actually a javascript function(method) which has a specific usecase. and now we are gonna learn about useEffect() hook.

//? UseEffect() hook:- this hook is also a javascript function, and while calling this method we have to pass two arguments , first one is a callback function and second one is a dependency array. so the first argument is a callback function , and this callback function will be called be useEffect hook when the component is rendered on the Ui and then it calls the callback function. here we are gonna use this UseEffect() hook inside the body component(to see go to Body.js) , so that means when rendering of the Body component will be rendered on the Ui only then useEffect hook will call the callback function which we passed inside it.So now we can say that, when we need to do something after the component renders then we have to use useEffect hook.
//*we can also go to sources tab of the developer tools and inside Body.js we can add debugger(breakpoints) one front of useEffect and another front of return keyword where the component returns, we will see that useEffect hook will only call the callback function when the component rendering has been rendered.
//* but why are we learning useEffect() hook? because using it we can easily implement the second way of fetching data when the user opens the page, so first we will render the body component with skeleton data and then make the api call inside the useEffect hook, so the call will happen only when the component is rendered.and to do fetching let's go to swiggy's website and get the url they use for their api. and then using the fetch method(a browser api not part of javascript) we will try to fetch the same object from the api..
//*but after trying to fetch we will get an error in the console.The error is because of cors policy. so according to the this cors policy we can't make a api call to this api url because the origin is different, so we are making the call is localhost origin, but the api is from swiggy's origin, and to deal with this problem we can install an extension named "CORS: Access-Control-Allow-Origin" from chrome web store . then after activating this extension from extension tab, we will see that the error will be gone and we are able to fetch data from the swiggy's api url.

//* so till we were rendering from the mockData which we saved as the value of the state variable named `listOfRestaurants`. and then we were iterating this array of objects using map method. then rendering the cards from the mockData, but now we are gonna make it really dynamic, so to do that first we will render the the fake data from mockData and then after rendering it then we will make the api call to get the real data from api inside useEffect() hook so all of this can happen when the component is already rendered. then after the real data comes we will again change the value of the state variable, and this time the state variable's value will be the real data we just received from the api, and as the state variable's value changes so it will automatically re-render the UI. we can't pass directly json inside the setLisTOfRestaurants() beacuse we to pass the same format of array of objects as mockData. so to that inside the useEffect hook after fetching the data, we will pass this:-setListOfRestaurants(json.data.cards[1].card.card.gridElements.infoWithStyle.restaurants); so to  keep the format same,  .
//* so till we were rendering from the mockData which we saved as the value of the state variable named `listOfRestaurants`. and then we were iterating this array of objects using map method. then rendering the cards from the mockData, but now we are gonna make it really dynamic, so to do that first we will render the the fake data from mockData and then after rendering it then we will make the api call to get the real data from api inside useEffect() hook so all of this can happen when the component is already rendered. then after the real data comes we will again change the value of the state variable, and this time the state variable's value will be the real data we just received from the api, and as the state variable's value changes so it will automatically re-render the UI. we can't pass directly json inside the setLisTOfRestaurants() beacuse we to pass the same format of array of objects as mockData. so to that inside the useEffect hook after fetching the data, we will pass this:-setListOfRestaurants(json.data.success.cards[1].card.card.gridElements.infoWithStyle.restaurants); so to  keep the format same,  .
//* now our cards component is fully dynamic , and till now the default value of the state variable was resList(mockData) , and for testing purpose we were the cards components with the mockdata when the user loads the page then after rendering all the components , we were making api call then after receiving the data we are re rendering the cards, so the user will not see any blank page when he opens the page, and now it's time to complete it , after making the component dynamic we are now setting the state variable's  default value to an empty array, so first the the Ui will render but without the cards then the data comes from api then we display the cards. so the user will not see any blank page at first, instead he will see the the UI , with empty cards then when the datat arrives we display the cards.
//* so while changing the state variable data by this:- json.data.success.cards[1].card.card.gridElements.infoWithStyle.restaurants , with this deep object , we should not directly write it instead we should optional chaining to write it , so any property doesn't exist then we can get undefined .so the current format should be :- json?.data?.success?.cards[1]?.card?.card?.gridElements?.infoWithStyle?.restaurants.

//*So now our state variable's Default value is an empty array previously we were showing some fake cards for testing purposes and we were showing those fake cards before the api response so the user would not see any blank page ,But now as we set its value To an empty array that's why when the user loads the page immediately the ui will appear but inside the body no cards will appear But that's not what we wanted so while we were loading the data from the api then we could also show a loading spinner and to do that we just need to write a if condition inside the body component so actually what we need to do is actually inside the if condition we will just write that if the list of restaurant.length === 0; Then load a spinner and to load a spinner we would have to make another component which will be rendered when the api is loading the data
//*⁡⁣⁢⁣Shimmer Ui⁡:-but using a loading spinner is not a modern practise in today's world and in the current world scenario most of the popular websites use something called shimmer ui and to create a shimmer ui for our web app first we need to understand that what is it so previously before loading the data we were showing fake cards using mog data but when we use shimmer ui then we basically display some skeleton cards that means cards Which looks very similar to the actual cards but these skeleton cards does not contain any data inside them and usually developers use a grey color for this skeleton cards and all of this is created because when the data arrives and we render the actual cards with real data then it makes the user feel that the blank skeleton cards are getting filled with real data so some colorful cards so the user was not seeing any drunk page or some fake cards with some fake data or even not a loading spinner instead now he is gonna see some skeleton card which are gonna be filled up when the actual data arrives and it makes the user experience so much better and the user feels that the web app is loading so much faster.So let's create a shimmer Ui for our component.we will create a another file named Shimmer.js and then create a function component which resembles to our present component but with no data and greyish color. and we will render that when the listOfRestaurants is empty so basically before loading the page.
//*Conditional Rendering:- So conditional rendering just a fancy name of we just did right now so basically rendering on the basis of conditions so in the above example when our state variable was empty in that condition we rendered the shimmer ui so basically our skeleton ui which prevents the user to see a blank page and then whenever the real data response comes from the api then we save that inside the state variable and then instantly state variable will render the component and then these first condition becomes false Because now the state variable is not an empty array and now it is filled with the real data so now the real card components will be rendered so as a conclusion we can say that when we render components depending on different conditions that is then called a conditional rendering and as an example we can say that when a user loads a page at that time We display some fake components which are basically some skeleton components(shimmer ui) And then whenever the data comes as the response of the api then in that condition immediately we display the real data on the ui so depending on the condition we are rendering different things on the ui and this is called conditional rendering.
//*And to do this conditional rendering, it is not even necessary to use an if statement instead we can also use ternary operator which is more easier and clean way so let us also do that.

//* now let's refresh our knowledge about react state variables
/*
⁡⁣⁢⁣What is State in React?⁡
⁡⁢⁣⁣In React, state(react state variable) is actually a JavaScript object that holds data that can be used to influence the rendering of a component. In simple terms, think of it as any piece of information that can change over time and impact how your component appears or behaves. The state allows developers to create dynamic and interactive UIs by enabling components to respond to user input, API responses, or other events.

Why is State Important in React?
The state is a cornerstone of React development for several reasons:

Dynamic UIs: State allows you to create dynamic, data-driven UIs. Whether it’s updating a counter, displaying a list of items, or toggling between different views, the state enables your UI to respond to user interactions and changing data.
User Input Handling: React components can capture and respond to user input, such as clicks, keyboard events, and form submissions, by updating their state. This interaction is what makes web applications interactive and user-friendly.

Data Persistence: The state is essential for managing and persisting data within a component. For example, when a user fills out a form or interacts with a complex UI element, React components can store and manage this data using state.
Efficient Updates: React’s virtual DOM and reconciliation algorithm work hand in hand with the state to ensure that only the necessary parts of the UI are updated when the state changes. This efficiency is crucial for maintaining good performance in React applications.⁡
*/
//* So in simple words we can say that a state variable may look like a normal javascript variable but actually behind the scenes These state variable gives us so much control on our ui That we don't need to update the ui manually whenever something changes in the data because of the user's interaction so when the user interact with the ui Then react components keep track of all of the user's interactions Clicking on any button or hovering on any button or many other and because of this interactions whenever some data change in the state variable It will immediately trigger the react reconciliation algorithm And this algorithm is going to create immediately a virtual dom a virtual dom is basically a copy of the real dom so it is just a copy object of the real dom object and then with this updated virtual dom react uses it's diff algorithm And this diff algorithm basically compares the new virtual dom with the old virtual dom It is comparing the old component With the new updated component And then after finding the differences then it actually changes the real dom and basically re render the whole component(call the functional component again using new data) using the new virtual dom So after comparing two virtual dom and finding the updated difference then react changes the real dom And this happens every time we change something in the state variable and this process happens so much fast which makes react so much faster in dom manipulation And it makes easier to make a component dynamic so basically depending on the change of data the behaviour of the ui will change or we can say the ui will be rendered Depending on the change of the data because of the user interaction if we would use a normal javascript variable instead of react state variable then even after changing the value of the javascript variable we are would have no way to know that something has changed in the data level and it needs to re render the component to display the change on the ui but as we are using a react state variable Now it is so much easier for react to know that because of some user interaction the data is manipulated And as soon as any state variables data is manipulated it immediately triggers the react reconciliation algorithm and updates the whole component inside which the state variable is located so the state variable helps us so much to make the user experience so much better by keeping the data layer in sink With the ui layer and because of the user interaction on the ui layer if something changes in the data layer then it will immediately also re render the ui layer By using reconciliation process.And even we use the const keyword To create the state variable we can still change the value of the state variable now we may think that how it is possible to change a constant variable but behind the scenes A react street variable is actually a javascript object and whenever this re render process happens because of change in the state variables value then at that time react actually creates a new instance so a new react state variable with the updated value and the old constant variable and this new constant variable which is created after changing the value of the state variable is not the same this is actually a new react state variable with the updated value and that is why we can also change a constant variables value when we use the const keyword to create a react state variable.

//* ⁡⁣⁢⁣application of state variable to toggle log in to log out and log out to log in when ever the user the user clicks on the log in btn:-⁡ so in the header component we have to first create a log in btn , and then to change the button name dynamically on user click we will use a state variable. so we are gonna the save the btnName inside a state variable and when the use will click on the btn we will use onclick event listener and inside the the callback function of the onclick listener we are gonna toggle log in and log out by changing this button's name which is saved inside the state variable.
//* so let's go to the our header component and apply the above plan.

//* ⁡⁣⁢⁣important note about learning anything:- how is it working and why do we need to use it? and when to use it.⁡

//* ⁡⁣⁣⁢𝗕𝘂𝗶𝗹𝗱𝗶𝗻𝗴 𝗮 𝘀𝗲𝗮𝗿𝗰𝗵 𝗯𝗮𝗿 𝘁𝗼 𝘀𝗲𝗮𝗿𝗰𝗵 𝗿𝗲𝘀𝘁𝗮𝘂𝗿𝗮𝗻𝘁𝘀⁡

//* so now beside the top restaurants btn , we will create a restaurant searching btn, so let's go our body component and build the btn first.
//* so inside a div we created a text input element(for search box) and a search btn, now we want that when the user will click on the search btn , then on that click event , we get the inputted value from the input element, and then using that value we want to filter the restaurant cards and update the Ui after filtering, and a very important step is that we have to bind this input element with a local state variable to track what user is typing in the input box. now inside the body component we will first make a local stat variable named searchText. and no to bind this variable with the input element , we need to use an attribute inside the input element named "value" and this attributes value will be the state variable we created. and the state variable's default value will be empty string as at first the search input's value should be empty. and after this now our input element is connected with state variable "searchText". but now if we try to tyoe anything on the search box then we are gonna see that nothing is happening in the search box and the search box is not taking any input and we can't write anything inside the search box. and the reason behind this is that, as we previously set the value  ={setText} so the default value of the state variable which is empty string , is basically preventing the Ui to input any data , because value={setSearchText} so we have to do something which allows us to change the state variable's value when the user types something in the search box(input elm) and to do that we know we have to use the the function which we get as the 1st index of the state variable's array. so "setSearchText()" function. but how to use it? , so want that when the user inputs something in the input element then the state variable's value should change so to do that we have to use a event listener inside the input elm named onChange listener , it basically gets triggered when user inputs something . and inside this event listeners callback function first we will receive the event as parameter and then use this event to get the value from the input elm and then call the setSearchText function with this value . so this will also change the value of the state variable. and now user can input any value and when the user click on the search btn then we can access that value and let's print that in the console first.
const AppLayout = () => {
  return (
    <div className="app">
      <Header />
      <Body />
    </div>
  );
};

const root = ReactDOM.createRoot(document.querySelector("#root"));

root.render(<AppLayout />);
